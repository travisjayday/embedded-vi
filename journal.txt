# Process Journal 

## Sun, Feb 29th, 9:00PM [1]
----------------------------------- 
This weekend I spewed out a basic implementation of VI.  It wasn't that hard and
I abstracted terminal/input/memory specific functions quit  well,  so  that  the
shift to embedded platforms would not be monumental. 

Right now, however, I  realized  that  the  way  I  handle  the  framebuffer  is
suboptimal.  Lines are stored in an array, and characters  are  stored  as  char
arrays in lines.  This means that inserting into lines is slow, and  deleting  /
inserting lines is slow too,  as  all  their  memory  has  to  be  re-allocated.
Specifically insertions run  at  O(n).   I  need  to  abstract  the  framebuffer
functions better so that I can make smarter implementatinos later.   I  think  a
doubly linked list would do well for lines, and maybe a GAP  structure  for  the
line data. 


## Mon, March 1st, 3:12PM [2] 
----------------------------------- 
I've just implemented the doubly linked list structure for handling the lines in
vi.  I'm quite happy about it, as it works quite well and flowed naturally  into
the code.  By keeping track of which line the cursor is on, incredibly fast line
inserts  and  deletes  can  be  made.   See  table  1  for  asymptotic   speeds.
     

## Tue, March 2nd, 3:12PM [3] 
----------------------------------- 
Last night I stayed up to implement the gap buffer mechanism.  After  a  lot  of
off-by-one errors, and memory corruptions,  I  figured  I'd  take  the  time  to
implement unit-test functionality.  I wrote up a couple tests for my gap  buffer
implementation and debugged it like that.  The gap  buffer  is  actually  pretty
cool. Now I have crazy fast O(1) inserts at the cursor position until the gap to
the right of the cursor gets filled.  At that point, full O(n)  reallocation  is
needed to grow the gap again.  Making the gapsize big though,  results  in  O(1)
amortized inserts.  Moving the cursor left or right also  takes  constant  time;
however, moving the cursor up or down may take up to O(n), as the gap  needs  to
be moved to the new cursor location.  I've updated the speed  table  to  reflect
this. 

Next, I will need to implement backspace deletes which should be easy, and  I'll
have my full gap buffer implementation.  After that, now that I have really nice
datastructures,   I   need   to   flesh    out    vi    with    more    commands

I'm back. Implementing character deletion was a matter of 5 lines with gap
buffers! Perfect. 

## Sat, March 7th, 1:12PM [4] 
----------------------------------- 
I realized that it's easier  to  re-adjust  the  gap  whenever  the  cursor  row
changes. Re-adjusting the gap only on inserts, delays the gap re-adjustment such
that moving left and right  copies  characters  around,  resuling  in  undefined
behavior and crashes.  In the future, I could write  logic  to  take  that  into
account, but for now, I will settle or O(n) row changes. 

To-day I also, implemented scrolling. Because of the linked nature of the lines,
maintaining a poitner to the first visible line  on  screen  makes  it  easy  to
exhcnage that with is successor or predecessor, then re-drawing for an effective
row-shift of the entire visible framebuffer.  

## Sun, March 8th, 11:31PM [5] 
----------------------------------- 
I've constructed a rudamentary  history  tracking  method.   Each  edit  can  be
represented by a command struct which contains a command, the  location  of  the
cursor, and an argument. For every action, the corresponding command is put into
a datastructure to keep track of historical actions. 

I chose to create a circular stack-like structure.  This structure  requires  no
dynamic allocations at runtime and  acts  similiar  to  a  ringbuffer.   A  tail
pointer, acting as a base pointer, and a head pointer acting as a stack  pointer
exist.  To add an item, the function `next()` returns  a  void  pointer  to  the
current head.  We can then modify the poitner and call `push()`  to  commit  the
changes to the buffer.  The buffer can be pushed to infinitely but can  only  be
popped a finite amount of times. On every pop, the head pointer gets decremented
until it reaches the tail pointer.   Due  to  this  nature,  this  structure  is
extremely well-suited for keeping track of undo's.  Push and pops  are  constant
time and it takes a constant amount of memory (VI_HISTORY_SIZE * sizeof(cmd_s)).

## Wed, March 10th, 4:16PM [6]
----------------------------------- 
I've started implementing delete mode, so now DD'ing lines is possible.
Backspacing to remove lines in insert mode is also possible. By adding each of
these features, I needed to re-construct the reverse operation in order to undo
them properly. This proved more difficult than anticipated as there existed
several edge cases (such as DD'ing the first or last line of a file, etc.). I
also discovered some bugs that messed up maintaining the invariance of certain
pointers such as head and tail pointers. The codebase is growing. At 1700 lines
and 30 files, I feel myself losing control. 
                   

# Figures 
----------------------------------- 

    +-----------------------------------+-----------+-------+
    | Framebuffer Operations            | Speed     | Entry |
    +-----------------------------------+-----------+------++
    | line inserts at beginning of file |  O(1)     |    #2 |
    +-----------------------------------+-----------+-------+
    | line inserts after cursor         |  O(1)     |    #2 |
    +-----------------------------------+-----------+-------+
    | line inserts at end of file       |  O(1)     |    #2 |
    +-----------------------------------+-----------+-------+
    | inserts at cursor                 |  O(1) am. |    #3 |
    +-----------------------------------+-----------+-------+
    | backspace deletes at cursor       |  O(1)     |    #3 |
    +-----------------------------------+-----------+-------+
    | moving cursor left or right       |  O(1)     |    #3 |
    +-----------------------------------+-----------+-------+
    | moving cursor up or down          |  O(n)     |    #3 |
    +-----------------------------------+-----------+-------+

    Table 1: Operations supported by vi. `n` = length of line. 
 
